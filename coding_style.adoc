= cppfw coding style

== C++ naming conventions

. All names (classes, functions, variables, template arguments etc.) are lowercase snake case.
.. Class and type names do not have any special suffixes, like `_t`.
.. Template arguments are also without any prefixes/suffixes.
.. To avoid variable and getter function names collision the variable can be given distinct name, or the `get_` prefix can be added into the getter function name.
. Preprocessor macro names are uppercase snake-case. E.g. `MY_SUPER_DUPER_MACRO`. Macros must only be used for conditional compilation purposes.

Example:

[source,cpp]
....
#define ENABLE_SOME_STUFF

class node{

  int node_size;

  int length;

public:
#ifdef ENABLE_SOME_STUFF
  const float some_stuff = 3.14159f;
#endif

  node(){}
  ~node(){}
  
  // shorter/clearer name is preferred for public interface (in this case - function name),
  // than for private things (in this case - variable name)
  int size(){
    return this->node_size;
  }
  
  int get_length(){
    return this->length;
  }
  
  void some_function(){
    this->length += 1;
  }

  template <class parameter>
  parameter universal_function(parameter p){
	  return p + 13;
  }
};
....

== C++ code formatting

**There are no any strict rules for code formatting!**

Though the following are preferred:

. Use tabs for indentation.
. In expressions, operators are surrounded by 1 space.
+
[source,cpp]
....
int a = 3.14159f + 2.7f * 3 / 12;
....
. Block opening curly bracket on the same line as it's related declaration.
. No space around parentheses.
+
[source,cpp]
....
int function(int a, int b){
	int ret = 0;
	for(int i = 0; i != 13; ++i){
		ret += a - b;
	}
	return ret;
}
....
. Continuation indentation, i.e. when expression is split over several lines, is two normal indentations (e.g. 2 tabs).
+
[source,cpp]
....
int a = 3.14159f + 2.7f + some_function() +
		some_other_function() + 13;
|->	|->	|
....

. Put `template <class param, ...>` on a separate line when declaring templates.
+
[source,cpp]
....
template <class parameter>
class my_template_class{
	// ...
};
....
. When function arguments or template arguments are to be split over several lines, the following rules apply:
.. Continuation indentation is used for argumetns.
.. Each argument goes on a separate line.
.. The first argument goes on a separate line.
.. The argument list closing bracket goes on a separate line.
.. The function body opening curly bracket goes on a separate line with same indentation as the function declaration start.

+
[source,cpp]
....
template <
		class parameter,
		class argument,
		int count
	>
void function(
		parameter a,
		argument b
	)
{
	for(int i = 0; i != count; ++i){
		// do something
	}
	return;
}
....

. Class single inheritance parent goes on the same line or on the new line. Same for constructor initializers.
+
[source,cpp]
....
class my_new_class : public parent_class{
public:
	int a;
	my_new_class(int a) : a(a) {}
};

class my_other_class :
		public parent_class
{
public:
	int a;
	my_new_class(int a) :
			a(a)
	{}
};
....

. Class multiple inheritance parents go on separate line each. Same for constructor initializers.
+
[source,cpp]
....
class my_new_class :
		public parent_class1,
		public parent_class2
{
public:
	int a;
	int b;
	my_new_class(int a, int b) :
			a(a),
			b(b)
	{}
};
....

. The `switch`-`case` is formatted as follows:
+
[source,cpp]
....
switch(expression){
	case value_1:
		// do something
		break;
	case value_2:
		{
			int some_var = 4;
			if(expression_2){
				break;
			}
			// do something else
		}
		break;
	default:
		break;
}
....
